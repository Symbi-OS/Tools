#include "L2/sym_probe.h"
#include "L0/sym_lib.h"
#include "L1/sym_interrupts.h"
#include "L2/sym_lib_page_fault.h"

#include <string.h>

#include "LIDK/idk.h"

// This is the old handler we jmp to after our interposer.
uint64_t orig_asm_exc_int3;
uint64_t orig_asm_exc_db;

uint64_t cr3_reg = 0;


static void (*myprintk)(char *);

unsigned char reset_byte = 0xf;

uint64_t int3_count = 0;
uint64_t int3_rdi = 0;
uint64_t int3_rsi = 0;
uint64_t int3_rdx = 0;

uint64_t addr_msg = 0;

static void tu_c_entry(){
  // HACK: safe way is to generate pointer into pt_regs
  // This looks safe for first 3 args for now.
  // RAX def gets clobbered XXX

  // tcp_sendmsg
  unsigned char *ucp = (unsigned char *) 0xffffffff81b50d00;
  *ucp = 0xf;
  int3_count++;

  // looks good in objdump
  asm("\t mov %%rdi,%0" : "=rm"(int3_rdi));
  asm("\t mov %%rsi,%0" : "=rm"(int3_rsi));
  asm("\t mov %%rdx,%0" : "=rm"(int3_rdx));

  memcpy((void *)addr_msg, (void*)int3_rsi, 96);
  return;

  myprintk("hey\n");

  uint64_t my_cr3;
  GET_CR3(my_cr3);
  if(cr3_reg == my_cr3){
    myprintk("wow, cr3 matches\n");

    myprintk("Need to swing overwritten byte back to 0xf\n");
    unsigned char *ucp = (unsigned char *) 0xffffffff810fbfe0;
    *ucp = reset_byte;
  }else{
    myprintk("Bummer, no match\n");
  }
}

uint64_t db_rdi = 0;
uint64_t db_rsi = 0;
uint64_t db_rdx = 0;

uint64_t dr6;

static void rs_c_entry(){
	
  //printf("DEBUG EXCEPTION FIRE\n");

  asm("\t mov %%rdi,%0" : "=rm"(db_rdi));
  asm("\t mov %%rsi,%0" : "=rm"(db_rsi));
  asm("\t mov %%rdx,%0" : "=rm"(db_rdx));
  asm("mov %%db6, %0" : "=r"(dr6));

  /*if(dr6 & 1)
    printf("DR0 HIT\n");
  if(dr6 & 2)
    printf("DR1 HIT\n");
  if(dr6 & 4)
    printf("DR2 HIT\n");
  if(dr6 & 8)
    printf("DR3 HIT\n");
  */
  dr6 = dr6^1;
  asm("mov %0,%%db6" :: "r"(dr6));
  printf("DR6: %lx\n", dr6);
}

// NOTE: This function is not used in C code, but is used in inline assembly.
// This asks the compiler not to warn about it being unused.
static uint64_t __attribute((unused)) my_entry = (uint64_t) &tu_c_entry;
static uint64_t __attribute((unused)) rs_entry = (uint64_t) &rs_c_entry;

extern uint64_t int3_jmp_to_c;
MY_INT3_HANDLER(int3_jmp_to_c, *my_entry);

extern uint64_t db_jmp_to_c;
MY_DB_HANDLER(db_jmp_to_c, *rs_entry);

// This is the name of our assembly we're adding to the text section.
// It will be defined at link time, but use this to allow compile time
// inclusion in C code.
extern uint64_t bs_asm_exc_int3;

extern uint64_t bs_asm_exc_db;

void sym_probe_init(){
  printf("Init SP\n");
  myprintk =  sym_get_fn_address("printk");
}

void sym_interpose_on_int3_ft_c(unsigned char * my_idt){
  /* sym_print_idt_desc(my_idt, X86_TRAP_BP); */

  // Get ptr to pf desc
  union idt_desc *desc_old;
  desc_old = sym_get_idt_desc(my_idt, X86_TRAP_BP);

  // save old asm_exc_pf ptr
  union idt_addr old_asm_exc_int3;
  sym_load_addr_from_desc(desc_old, &old_asm_exc_int3);

  // This is stored, but not used.
  orig_asm_exc_int3 = old_asm_exc_int3.raw;

  // New handler
  union idt_addr new_asm_exc_addr;
  new_asm_exc_addr.raw = (uint64_t) &int3_jmp_to_c;

  // Set IDT to point to our new interposer
  sym_load_desc_from_addr(desc_old, &new_asm_exc_addr);

  /* sym_print_idt_desc(my_idt,  X86_TRAP_BP); */
}

void sym_interpose_on_db_ft_c(unsigned char * my_idt){
  sym_print_idt_desc(my_idt, X86_TRAP_DB);

  // Get ptr to pf desc
  union idt_desc *desc_old;
  desc_old = sym_get_idt_desc(my_idt, X86_TRAP_DB);

  // save old asm_exc_pf ptr
  union idt_addr old_asm_exc_db;
  sym_load_addr_from_desc(desc_old, &old_asm_exc_db);

  // This is stored, but not used.
  orig_asm_exc_db = old_asm_exc_db.raw;

  // New handler
  union idt_addr new_asm_exc_addr;
  new_asm_exc_addr.raw = (uint64_t) &db_jmp_to_c;

  printf("SET IDT HANDLER ADDR: %p\n", (void *)&db_jmp_to_c);
  
  // Set IDT to point to our new interposer
  sym_load_desc_from_addr(desc_old, &new_asm_exc_addr);

  sym_print_idt_desc(my_idt, X86_TRAP_DB);
}

unsigned char sym_set_probe(uint64_t addr){
  // TODO if write spans pages, this will fail.
  sym_elevate();
  unsigned char ret = *(unsigned char *) addr;
  sym_lower();
  sym_make_pg_writable(addr);

  sym_elevate();
  // Magic write int3 instruction.
  *(unsigned char *) addr = 0xcc;
  sym_lower();

  return ret;
}

unsigned char sym_set_db_probe(uint64_t addr){
  // TODO if write spans pages, this will fail.
  sym_elevate();
  unsigned char ret = *(unsigned char *) addr;
  sym_lower();
  uint64_t dr7 = 2;
  sym_elevate();
  // place addr into DR0
  asm("\t mov %0,%%db0" :: "r"(addr));
  asm("\t mov %0,%%db7" :: "r"(dr7));
  sym_lower();

  return ret;
}
